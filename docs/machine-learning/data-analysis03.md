# 03 - NumPy (3)

## 一、NumPy 中的广播

前面提到，对两个 NumPy 数组实施加减乘除等运算需要两个数组的形状相同。实际上，NumPy 具有智能填充的功能，当两个数组形状不一样时，可扩充较小数组中的元素来匹配较大数组的形状，这种机制称为“**广播**(broadcasting)”，也称为张量自动扩展，是一种轻量级的张量复制手段。

![NumPy 中的广播机制](/img/data-analysis-03-01.jpg)

对于大部分场景，广播机制仅仅在逻辑上改变了张量的尺寸，只待实际需要时才真正实现张量的赋值和扩展。这种优化流程节省了大量计算资源，并由计算框架(如 NumPy)隐式完成。

```python
import numpy as np

a = np.arange(3)
print(a + 5)
print(a)

# [5 6 7]
# [0 1 2]
```

广播机制也支持将两个张量同时扩展，以适应对方的张量维度。

```python
import numpy as np

a = np.arange(3).reshape(3, 1)
b = np.ones(3)
print(a + b)

# [[1. 1. 1.]
#  [2. 2. 2.]
#  [3. 3. 3.]]
```

综上，NumPy 的广播机制为：

- **扩展维度**：如果两个张量的尺寸不同，则 NumPy 的广播机制会为尺寸较小的张量添加一个轴(广播轴)，使其维度信息与较大张量的相同。
- **复制数据**：尺寸较小的张量沿着新添加的轴不断重复之前的元素，直至尺寸与较大的张量相同。
- **低维有 1**：如果两个张量的尺寸在任何维度上都不匹配，则需将某维度中尺寸为 1 的张量拉伸，以匹配另一个较大张量的尺寸。

如果两个张量在任何维度上尺寸都不一致，且两者均没有任何一个维度为 1，则会出现广播错误，即广播不会发生。也就是说，为了让广播操作能够顺利进行，广播操作的两个对象，它们某个维度上的尺寸，要么相等，要么为 1。

## 二、NumPy 数组的高级索引

### 1. 花式索引

前面通过索引访问数组中的值，索引要么是一个值(访问一个元素)，要么是一片值(切片访问)。如果需要一次性访问数组中的多个无规律元素，则需要使用**花式索引**(Fancy Indexing)：将多个需要访问元素的索引组成一个整型数组，然后把这个内含索引的数组整体作为目标数组的索引。花式索引也成为整数索引。

```python
import numpy as np

a = np.array([12, 37, 65, 42, 58, 93, 52, 18, 66])
b = a[[2, 5, 3]]
print(b)

# [65 93 42]
```

对二维数组，当传入的参数只有一个整数数组时，表示访问对应的行。花式访问不同列时，需要用冒号 `:` 添加一个维度：

```python
import numpy as np

a = np.array([[0, 1, 2],
              [3, 4, 5],
              [6, 7, 8],
              [9, 0, 1]
              ])
b = a[:, [2, 0, 1]]
print(b)

# [[2 0 1]
#  [5 3 4]
#  [8 6 7]
#  [1 9 0]]
```

花式访问二维数组中任意坐标的元素，则需要提供两个花式索引(都以数组形式存在)，分别对应行坐标和列坐标，这样系统会自动两两配对，构成一个二维数组坐标，然后一一获取坐标点位置所指引的数值。

```python
import numpy as np

a = np.array([[0, 1, 2],
              [3, 4, 5],
              [6, 7, 8],
              [9, 0, 1]
              ])
b = a[[0, 3, 2], [2, 0, 1]]
print(b)

# [2 9 7]
```

此外，花式索引还可以在索引的过程中进行元素的过滤：

```python
import numpy as np

a = np.array([[0, 1, 2],
              [3, 4, 5],
              [6, 7, 8],
              [9, 0, 1]
              ])
row_index = np.array([0, 2, 1])             # 花式访问的行
col_mask = np.array([1, 0, 1], dtype=bool)  # 列访问掩码
b = a[row_index[:, np.newaxis], col_mask]
print(b)

# [[0 2]
#  [6 8]
#  [3 5]]
```

上面代码中定义的访问掩码是一个布尔类型的数组。`np.newaxis` 在功能上等价于 None，含义是为数组添加一个轴，将 `row_index` 变为二维数组，这样后一个参数 `col_mask` 就不会被解析为坐标。根据上面代码中 `col_mask` 的站位，它是为“列”服务的，表明了那些列是可取的、那些列是需要过滤的。

使用掩码的方法就是下面要讨论的布尔索引。

### 2. 布尔索引

通过**布尔索引**，我们可以有选择性地提取数组中感兴趣的行或列(对应位置为 True 的保留，反之则过滤)。

```python
import numpy as np

a = np.arange(10).reshape((2, 5))
print(a[a > 5])

# [6 7 8 9]
```

上面的代码中，`5` 会被广播为与数组 `a` 形状一致的数组，然后数组 `a` 中的每个元素都会与 5 进行比较，得到一个形状与数组 `a` 相同的**布尔数组**。布尔数组整体作为一个索引，构成一个**布尔索引**，NumPy 会根据逐元素(element-wise)规则返回对应位置布尔值为 True 的值。

## 三、数组的堆叠与分割

有时需要将不同的 NumPy 数组通过**堆叠**操作拼接为一个新的较大数组。堆叠方式大致分为水平方向堆叠(horizontal stack)、垂直方向堆叠(vertical stack)、深度方向堆叠(depth-wise stack)等。

![NumPy 中数组堆叠方向类比](/img/data-analysis-03-02.jpg)

除此之外，堆叠函数还包括 `concatenate()`、`column_stack()`、`row_stack()` 等。

### 1. 水平方向堆叠

水平方向堆叠函数 `hstack()` 会将所操作的数组按列顺序堆叠起来。该函数的参数是一个元组，元组内被堆叠的数据对象可以是列表，也可以是 NumPy 数组，结果返回 NumPy 数组。使用 `concatenate()` 函数，并设置水平轴方向 `axis=1` 的连接，也可以达到相同的堆叠效果：

```python
import numpy as np

a = np.zeros((2, 3))
b = np.ones((2, 2))
print(np.hstack((a, b)))
print(np.concatenate((a, b), axis=1))


# [[0. 0. 0. 1. 1.]
#  [0. 0. 0. 1. 1.]]
# [[0. 0. 0. 1. 1.]
#  [0. 0. 0. 1. 1.]]
```

注意：`hstack()` 要求参与堆叠操作的两个数组在垂直(即行)方向的尺寸是相同的。如果我们将 `axis=0` 视为第一个轴，将 `axis=1` 视为第二个轴，以此类推，`hstack()` 完成数组堆叠的前提是，除了第二个轴的维度尺寸不一样，参与堆叠的数组在其他维度的尺寸必须要一致。

### 3. 垂直方向堆叠

`vstack()` 实现的是垂直方向 `axis=0` 的数组堆叠。其用法与 `hstack()` 相似：

```python
import numpy as np

a = np.zeros((2, 3))
b = np.ones((1, 3))
print(np.vstack((a, b)))
print(np.concatenate((a, b), axis=0))

# [[0. 0. 0.]
#  [0. 0. 0.]
#  [1. 1. 1.]]
# [[0. 0. 0.]
#  [0. 0. 0.]
#  [1. 1. 1.]]
```

类似于 `hstack()`，为了完成数组堆叠操作，`vstack()` 要求除第一个轴(参与堆叠)方向的维度尺寸不一样以外，其他维度的尺寸必须保证一致。

### 3. 深度方向堆叠

`dstack()` 函数可以把一系列数组在第三维度进行堆叠。

```python
import numpy as np

a = np.arange(0, 9).reshape((3, 3))
b = np.arange(9, 18).reshape((3, 3))
c = np.arange(18, 27).reshape((3, 3))
print(np.dstack((a, b, c)))

# [[[ 0  9 18]
#   [ 1 10 19]
#   [ 2 11 20]]
# 
#  [[ 3 12 21]
#   [ 4 13 22]
#   [ 5 14 23]]
# 
#  [[ 6 15 24]
#   [ 7 16 25]
#   [ 8 17 26]]]
```

该函数常用于图像数据在不同通道上(如 RGB)的叠加。

### 4. 列堆叠与行堆叠

除了上面的数组堆叠方式之外，还可以通过 `column_stack()` 方法实现一维数组按列方向(column-wise)堆叠，效果与 `hstack()` 等价：

```python
import numpy as np

a = np.arange(3)
b = 2*a
print(np.column_stack((a, b)))

# [[0 0]
#  [1 2]
#  [2 4]]
```

类似地，还有行方向的堆叠(row stacking)函数 `row_stack()`，效果与 `vstack()` 等价。

### 5. 数组的分割操作

分割是堆叠的反向操作。和堆叠类似，分割也包括水平方向分割、垂直方向分割和深度方向分割，分别用 `hsplit()`、`vsplit()` 和 `dsplit()` 实现。

类似于 `concatenate()` 方法可通过设置轴方向，既实现水平方向堆叠，又实现垂直方向堆叠， `split()` 也可以通过设置分割方向，分别实现 `hsplit()`、`vsplit()` 和 `dsplit()` 的功能。

以 `hsplit()` 为例，该函数的调用方法为：

```python
np.hsplit(ary, indices_or_sections)
```

`ary` 表示要分割的数组，`indices` 如果只有一个数值，表示水平等分数组(要保证数组能被等分，否则会报错)，如果分割的位置不止一个，则用 `sections` 来表达。`sections` 可以是一个数组，也可是一个列表，其中的整数元素依次代表分割的位置。

```python
import numpy as np

a = np.arange(18).reshape((3, 6))
print(np.hsplit(a, 3))

# [array([[ 0,  1],
#        [ 6,  7],
#        [12, 13]]), array([[ 2,  3],
#        [ 8,  9],
#        [14, 15]]), array([[ 4,  5],
#        [10, 11],
#        [16, 17]])]
```

可以看到，`hsplit()` 的返回值是一个包含子数组的列表。

## 四、NumPy 中的随机数模块

`numpy.random` 模块中提供了大量与随机数相关的函数。

```python
import numpy as np

np.random.seed(1)                       # 定义随机种子
print(np.random.rand(2, 3))             # 生成 2x3 随机数组，服从均匀分布
print(np.random.randn(2, 3))            # 生成 2x3 随机数组，服从标准正态分布
print(np.random.randint(1, 10, (2, 3))) # 生成 [1,10) 的 2x3 随机整数数组
print(np.random.random((2, 3)))         # 生成 [0,1) 的 2x3 随机数组

# [[4.17022005e-01 7.20324493e-01 1.14374817e-04]
#  [3.02332573e-01 1.46755891e-01 9.23385948e-02]]
# [[-0.52817175 -1.07296862  0.86540763]
#  [-2.3015387   1.74481176 -0.7612069 ]]
# [[3 5 8]
#  [8 2 8]]
# [[0.93912779 0.77838924 0.71597052]
#  [0.8027575  0.09280081 0.51815255]]
```

如果随机种子固定，那么产生的随机数就固定了，本质上，它们都是“伪随机数”。这是因为，真正的随机数是没有规律的，凡是被设计出来的随机数，某种程度上都不那么随机。如果不指定随机种子，系统会把时间作为随机种子，由于时间流逝，每时每刻的时间都不同，即随机种子不同，所以每次产生的随机数都不同，这样设计的随机数生成器也更加随机。
