# 04 - 面向对象

## 一、面向过程(POP)与面向对象(OOP)

图灵奖得主尼古拉斯·沃斯(Nicklaus Wirth)：

$$
程序 = 算法 + 数据结构
$$

这个说法，演绎出来的编程范式使结构化程序设计，即面向过程编程(Procedure Oriented Programming，POP)。POP 的开发范式是把程序划分为两个相互分离的部分：数据表示(即数据结构)和数据操作(即算法)。算法可以通过顺序、选择、循环三种基本控制结构来实现，数据结构指的是结构化程序设计。因此，POP 的核心侧重于数据结构和算法的开发于优化，强调程序的易读性。Linux、Git 都是基于 POP 的。

POP 的缺点在于，程序之间环环相扣，如果需求发生变化，代码改动会很大，对软件后期维护和扩展不利。而面向对象设计(Object Oriented Programming，OOP)很好地解决了这一问题，其设计思想概括为：

$$
程序 = 对象 + 消息传递
$$

用户首先自定义一个数据结构 — 类，然后用该类下的对象组装程序。对象之间通过“消息”进行通讯。每个对象中既包括数据，也包括对数据的处理。每个对象之间彼此协作又互不干扰。

OOP 使得程序更容易扩展和维护。但缺点也有：执行效率比 POP 低。所以，对于科学计算和要求高效的任务，POP 比 OOP 更加实用。而且，OOP 的复杂度往往高于 POP，对于小型程序，使用 POP 要更加清晰。

ErLang 语言的发明人乔·阿姆斯特朗(Joe Armstrong)吐槽：

> 面向对象编程的问题在于，它总是附带着所有它需要的隐含环境，你想要一根香蕉，但得到的却是一只大猩猩拿着香蕉，而且还有整片丛林。

为了解决一个问题，POP 首先强调“怎么去做(How todo)”，对应的解决方案是一个个功能块 — 函数(Function)。而 OOP 首先考虑“是谁去做(Who to do)”，对应的解决方案使一个个“对象”，这些对象为解决问题所必须具备的能力，构成一个个方法(Method)。

OOP 中的对象是由数据和方法(即对数据的操作)构成的。

$$
程序 = 对象 + 消息传递 = (数据 + 方法) + 消息传递
$$

将具有的相同属性(数据)和相同行为(对数据的操作)封装在一起，即创造了新的类。类就是对某一事物的描述，它是抽象的、概念上的定义。对象是实际存在的该类十五中的个体，对象也被称为实例(instance)。一个类中可以定义多个对象，但每个对象是独立的存在，修改其中一个对象的属性不影响其他对象(全局共享的静态成员除外)。这体现了 OOP 的一个重要特性 — 封装性。

OOP 的重点是对类的设计，而非对象的实现。

## 二、类的定义与使用

一般而言，再面向对象编程中，函数和方法可以看作同义词。但再 Python 中，函数和方法还是有所不同的。方法是指于特定实例绑定的函数，因此，把类中的函数称为方法(类似于 Java)，而把不与实例绑定的普通功能称为函数。

```python
class Person:
    area = 'China'                  # 定义类的属性
    # 定义构造方法
    def __init__(self, name, age):
        self.name = name            # 定义对象的属性
        self.__age = age            # 定义对象的私有属性，类的外部无法直接访问
    # 定义类的方法
    def say(self):
        print(self.name, self.__age, self.area)

p1 = Person('Liu', 18)              # 实例化对象
p1.say()
p1.name = 'Niu'
p1.say()

# Liu 18 China
# Niu 18 China
```

Python 中类中的属性分为两类：属于类的属性和属于对象的属性。

- 属于类的属性为所有对象共享，类似于 C++、Java 中的静态属性。
- 属于对象的属性是指在构造方法 `__init__()` 中定义的属性(也可以在其他成员方法中定义)，这类属性必须以 `self` 开头，同一个类定义下的对象之间互不影响。
- 以两个下划线 `__` 开始的属性是私有属性，在类的外部无法直接访问，需要借助公有成员方法(类似于类的外部接口)。如上面代码中定义的 `say()` 方法就可以访问私有属性 `__age`。类似的，以两个下划线开始的方法方法表明它是一个私有方法，私有方法只能在类的内部被调用。
- 以一个下划线 `_` 开始的属性表示保护属性，不能通过 `from module import *` 的方式导入，只对自己和子类开放权限。
- 前后都有两个下划线的方法，表示 Python 自定义的特殊方法，如 `__init__`。

Python 中定义方法也使用 `def` 关键字，方法参数必须包括 `self` 且必须为第一个参数。

Python 可以为对象添加临时属性：

```python
p1.height = '180'
```

临时属性仅属于被添加的对象，不影响其他的对象。

## 三、类的继承

在 OOP 中，继承(Inheritance)是软件复用的关键技术。继承使子类可以复用父类的优秀属性，同时进一步扩展新的特性。

在已有的类的基础上新增自己的特性，继而产生新的类的过程，称为派生，把既有的类称为基类(Base Class)、超类(Super Class)或者父类(Parent Class)，将派生出的新类称为派生类(Derived CLass)或者子类(Subclass)。

Python 不仅支持类的继承，还支持多继承。但多继承存在“菱形继承”的风险：

> 菱形继承：两个类同时继承于同一个父类，又有子类同时继承这两个子类，最后子类中的属性存在二义性问题，即不知道他们来自哪个父类。

```python
class Person:
    area = 'China'                  # 定义类的属性
    # 定义构造方法
    def __init__(self, name, age):
        self.name = name            # 定义对象的属性
        self.age = age              # 定义对象的私有属性，类的外部无法直接访问
    # 定义类的方法
    def say(self):
        print(self.name, self.age, self.area)

class Student(Person):
    grad = ''
    def __init__(self, name, age, grade):
        # 调用父类的构造方法，初始化父类属性
        Person.__init__(self, name, age)
        self.grade = grade
    # 重写父类的同名方法
    def say(self):
        print(self.name, self.age, self.grade)

stu = Student('Liu', 19, 2)
stu.say()

# Liu 19 2
```

继承多个父类时，若父类中由相同的方法名，而在子类使用时未指定，Python 将从圆括号中的父类安装从左向右的顺序查找该方法，因此需注意父类的顺序。

当父类的方法不能满足子类的需求时，可以在子类中重写父类的方法，称为覆写(Override)。
