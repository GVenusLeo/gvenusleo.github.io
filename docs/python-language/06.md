# 06 - 文件与目录操作

## 一、打开文件

文件是记录在存储介质中的一组相关信息的集合。在操作系统中，文件名由文件主名和扩展名(可选)组成。Python 使用 `open()` 方法读取文件，传入文件名与标识符：

```python
file = open('filename', mode = 'r')
```

`file` 是一个文件对象，`filename` 是文件名(可以包括路径)，`mode` 为读写模式，默认为只读模式。如果文件不存在，则会抛出 `FileNotFoundError` 异常。

Python 文件的打开方式有多种：

| 模式 | 描述 |
| :---: | --- |
| `r` | 只读模式。若文件不存在则报错，文件指针指向开头。 |
| `w` | 只写模式。若文件不存在则创建，若文件存在则覆盖。 |
| `a` | 追加模式。若文件不存在则创建用于写入，若文件存在则文件指针指向结尾。 |
| `t` | 文本文件模式。 |
| `b` | 二进制模式。主要用于打开非文本文件，如图片、音频。 |
| `+` | 打开文件并允许更新(可读、可写)。 |

上表所列模式可以组合：

| 模式 | 描述 |
| :---: | --- |
| `rb` | 以二进制格式打开一个文件用于只读。文件指针指向开头。 |
| `r+` | 打开一个文件用于读写。文件指针将会放在文件的开头。 |
| `wb` | 以二进制格式打开一个文件只用于写入。若文件存在则覆盖。若该文件不存在，创建新文件。 |
| `w+` | 打开一个文件用于读写。若文件已存在则覆盖。若该文件不存在，创建新文件。 |
| `wb+` | 以二进制格式打开一个文件用于读写。若该文件已存在则覆盖。若该文件不存在则创建新文件。 |
| `ab` | 以二进制格式打开一个文件用于追加。若文件已存在则文件指针指向结尾。若该文件不存在则创建新文件。 |
| `a+` | 打开一个文件用于读写。若该文件已存在则文件指针指向结尾。若文件不存在则创建新文件。 |
| `ab+` | 以二进制格式打开一个文件用于追加。若文件已存在则文件指针指向结尾。若文件不存在则创建新文件。 |

读取完文件后，为了避免系统资源的浪费，应使用 `close()` 方法关闭文件。

由于文件读写过程可能产生 `IOError` 错误，造成 `close()` 方法无法调用，为了保证无论是否出错都能正常关闭文件，可以使用异常处理后 `with` 语句：

```python
# 异常处理方法
try:
    file = open('python.txt', 'r')
    print(file.read())
finally:
    if file:
        file.close()

# with语句
with open('python.txt', 'r') as file:
    print(file.read())
```

引入 `with` 语句，当我们访问完文件后，Python 会根据上下文语境自动调用 `close()` 方法。

## 二、读取文件

使用 `read()` 方法可以将文本文件中的数据一次性读取出来，也可以设置一个参数控制读取的字节数：

```python
txt1 = file.read()      # 全部读取
txt2 = file.read(20)    # 读取前20个字节
```

文件读取过程中，文件指针会随着系统的读取而移动，使用 `tell()` 方法可以返回当前文件指针的位置。若文件指针移动到文件尾部(EOF. end of file)，此时如果再使用 `read()` 方法读取文件，文件指针就无法继续下移，读取不到文件。解决该问题的方法是使文件指针复位，需要用 `seek()` 方法：

```python
file.tell()
file.seek(offset[, whence])
```

其中，`offset` 表示需要偏移的字节数，`whence` 默认值为 0，表示从哪个位置开始偏移，0 代表以文件开头为七起点，1 代表以当前位置为起点，2 代表以文件末尾为起点。

当文件很大很难一次性读入内存或数据是以行为单位时，可以使用 `readline()` 从文件中读取整行，该方法同样可以指定一个非负参数控制读入的字节数。如果需要一次性读取所有数据，同时要求以行为单位，可以使用 `readlines()` 方法，该方法返回包含所有行的列表。

## 三、写入文件

写入文件使用 `write()` 方法，需要打开时指定标识符包含 `w`：

```python
with open('python.txt', 'w') as file:
    file.write('Hello')
```

写入的内容必须是字符串，在文件关闭或缓冲区刷新前，字符串内容暂时存储在缓冲区。

## 四、`OS` 模块

Python 中操作文件和目录，可以使用内置的 `os` 模块调用操作系统提供的接口函数。比如参看操作系统类型：

```python
import os
print(os.name)

# posix: 表示Linux、Unix或Mac OS
# nt：表示Windows
```

获取操作系统的详细信息可以使用 `uname()` 函数，但该函数在 Windows 上不提供。

### 1. 环境变量

```python
import os

print(os.environ)               # 查看全部环境变量
print(os.envirom.get('PATH'))   # 获取指定环境变量
```

### 2. 操作文件和目录

```python
import os

print(os.getcwd())                          # 查看当前工作目录
print(os.path.abspath('path'))              # 查看目录绝对路径
print(os.listdir('path'))                   # 列出目录下所有文件和子目录
print(os.path.isdir(x))                     # 判断是否为目录
print(os.path.isfile(x))                    # 判断是否为文件 
print(os.path.join('doc', 'chinese'))       # 拼接路径
print(os.path.split('doc/chinese'))         # 拆分目录
print(os.path.splitext('/doc/chinese.md'))  # 拆分目录
os.mkdir('doc')                             # 创建新目录
os.rmdir('doc')                             # 删除目录
os.rename('chinese.txt', 'chinese.md')      # 文件重命名
os.remove('chinese.md')                     # 删除文件
```

拼接两个路径或拆分一个路径时，不能直接拼接字符串或拆分字符串，因为不同操作系统的路径分隔符是不一样的。`os.path.split()` 方法拆分得到的路径后一部分总是最后级别的目录或文件名，`os.path.splitext()` 方法则直接得到文件的扩展名。这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。
